[["index.html", "Normalization (BCB420 Lecture) Welcome 0.1 Learning goals 0.2 Example datasets", " Normalization (BCB420 Lecture) Ruth Isserlin Welcome This bookdown module turns the Lecture – Normalization slides into a hands-on, reproducible mini-book. 0.1 Learning goals By the end, learners should be able to: Visualize sample distributions with boxplots and density plots. Apply appropriate normalization methods for: bulk RNA-seq (e.g., TMM, DESeq2 size factors) single-cell RNA-seq (library-size scaling + log1p; conceptually) Evaluate normalization with diagnostic plots. 0.2 Example datasets We re-use the same GEO series as practical examples: GSE119732 (bulk RNA-seq) "],["what-is-normalization.html", "Chapter 1 What is normalization?", " Chapter 1 What is normalization? Normalization adjusts raw measurements so that samples become comparable by removing unwanted technical effects while preserving true biological signal. In sequencing-based expression data, raw counts reflect both: the amount of RNA (biology) sequencing depth, composition, gene length, etc. (technology) Normalization is one of the first steps in any analysis pipeline and can substantially affect downstream results. "],["technical-vs-biological-variation.html", "Chapter 2 Technical vs biological variation 2.1 Technical variation 2.2 Biological variation", " Chapter 2 Technical vs biological variation 2.1 Technical variation Examples: different sequencing depths (library sizes) batch effects (day, reagent, operator) gene length and GC content biases We aim to control/correct these. 2.2 Biological variation Differences due to the biology we care about: condition, tissue, genotype treatment, disease status Normalization should reduce technical variation while leaving biological variation intact. "],["visualizing-distributions.html", "Chapter 3 Visualizing distributions 3.1 load Some data 3.2 Boxplots 3.3 Density plots", " Chapter 3 Visualizing distributions Before choosing a normalization method, inspect data distributions. 3.1 load Some data library(GEOquery) ## Loading required package: Biobase ## Loading required package: BiocGenerics ## Loading required package: generics ## ## Attaching package: &#39;generics&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.difftime, as.factor, as.ordered, intersect, is.element, setdiff, ## setequal, union ## ## Attaching package: &#39;BiocGenerics&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, aperm, append, as.data.frame, basename, cbind, ## colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ## get, grep, grepl, is.unsorted, lapply, Map, mapply, match, mget, ## order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, ## rbind, Reduce, rownames, sapply, saveRDS, table, tapply, unique, ## unsplit, which.max, which.min ## Welcome to Bioconductor ## ## Vignettes contain introductory material; view with ## &#39;browseVignettes()&#39;. To cite Bioconductor, see ## &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. ## Setting options(&#39;download.file.method.GEOquery&#39;=&#39;auto&#39;) ## Setting options(&#39;GEOquery.inmemory.gpl&#39;=FALSE) library(knitr) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following object is masked from &#39;package:Biobase&#39;: ## ## combine ## The following objects are masked from &#39;package:BiocGenerics&#39;: ## ## combine, intersect, setdiff, setequal, union ## The following object is masked from &#39;package:generics&#39;: ## ## explain ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(tibble) if(!require(tidyverse)){ install.packages(&quot;tidyvers&quot;,dependencies = FALSE) } ## Loading required package: tidyverse ## Error: package or namespace load failed for &#39;tidyverse&#39;: ## .onAttach failed in attachNamespace() for &#39;tidyverse&#39;, details: ## call: library(pkg, lib.loc = loc, character.only = TRUE, warn.conflicts = FALSE) ## error: there is no package called &#39;lubridate&#39; ## Installing package into &#39;/usr/local/lib/R/site-library&#39; ## (as &#39;lib&#39; is unspecified) ## Warning: package &#39;tidyvers&#39; is not available for this version of R ## ## A version of this package for your version of R might be available elsewhere, ## see the ideas at ## https://cran.r-project.org/doc/manuals/r-patched/R-admin.html#Installing-packages library(tidyverse) gse &lt;- &quot;GSE119732&quot; source(&quot;./supp_functions.R&quot;) fetch_geo_supp(gse = gse) ## Using locally cached version of supplementary file(s) GSE119732 found here: ## data/GSE119732/GSE119732_count_table_RNA_seq.txt.gz path &lt;- file.path(&quot;data&quot;, gse) files &lt;- list.files(path, pattern = &quot;\\\\.txt.gz$|\\\\.tsv.gz$|\\\\.csv.gz$&quot;, full.names = TRUE, recursive = TRUE) Raw table preview library(readr) safe_read &lt;- function(file) { # First attempt: read as TSV df &lt;- tryCatch( readr::read_tsv(file, show_col_types = FALSE), error = function(e) NULL # catch fatal errors ) # If read_tsv failed entirely: if (is.null(df)) { message(&quot;TSV read failed — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If read_tsv returned but with parsing issues: probs &lt;- problems(df) if (nrow(probs) &gt; 0) { message(&quot;Parsing issues detected in TSV — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If everything was fine: return(df) } x &lt;- safe_read(files[1]) kable_head(x[, 1:min(6, ncol(x))], 5, paste(gse,&quot;: raw table preview&quot;)) (#tab:preview_raw)GSE119732 : raw table preview gene_id A1 A2 A3 A4 B1 ENSG00000223972.5 0 0 0 0 0 ENSG00000227232.5 79 119 84 50 80 ENSG00000278267.1 17 10 22 19 19 ENSG00000243485.4 0 0 0 0 0 ENSG00000237613.2 0 0 0 0 0 3.2 Boxplots library(tidyverse) # suppose &#39;mat&#39; is a gene x sample matrix (numeric) plot_box &lt;- function(mat, main = &quot;&quot;, ylab = &quot;log2(counts+1)&quot;) { df &lt;- as.data.frame(mat) df_long &lt;- df |&gt; mutate(gene = rownames(df)) |&gt; pivot_longer(-gene, names_to = &quot;sample&quot;, values_to = &quot;value&quot;) |&gt; mutate(value = log2(value + 1)) ggplot(df_long, aes(x = sample, y = value)) + geom_boxplot(outlier.size = 0.2) + theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) + labs(title = main, x = &quot;Sample&quot;, y = ylab) } plot_box(x[,2:ncol(x)]) 3.3 Density plots plot_density &lt;- function(mat, main = &quot;&quot;) { df &lt;- as.data.frame(mat) df_long &lt;- df |&gt; mutate(gene = rownames(df)) |&gt; pivot_longer(-gene, names_to = &quot;sample&quot;, values_to = &quot;value&quot;) |&gt; mutate(value = log2(value + 1)) ggplot(df_long, aes(x = value, colour = sample)) + geom_density() + theme_bw() + labs(title = main, x = &quot;log2(counts+1)&quot;, y = &quot;Density&quot;) + guides(colour = &quot;none&quot;) } plot_density(x[,2:ncol(x)]) "],["normalization-methods.html", "Chapter 4 Normalization methods 4.1 Library-size scaling 4.2 Distribution-based normalization 4.3 RNA-seq composition-aware methods 4.4 Single-cell note", " Chapter 4 Normalization methods Different assays require different methods. 4.1 Library-size scaling The simplest approach divides each sample by its total counts (or reads) to account for sequencing depth. 4.1.1 Counts-per-million (CPM) There are other versions of this type of normalization (RPKM, FPKM ,TPM,…) - all of them try to normalize for the library size (the number of reads in a given experiment) but some of them incorporate other factors as well. CPM - normalizes for just library size. TPM - normalzie for gene length, then library size. FPKM/RPKM - similiar but one uses reads and the other fragments. normalizes for gene length and library size at the same time. TPM is preferred. 4.2 Distribution-based normalization Methods like quantile normalization force sample distributions to match and are common in microarrays. 4.3 RNA-seq composition-aware methods Two widely used methods: TMM (edgeR): computes scaling factors to adjust effective library sizes. RLE / size factors (DESeq2): median-of-ratios approach. 4.3.1 edgeR: TMM TMM looks at most genes, ignores the weird ones, figures out how different two samples really are, and uses that to scale the samples so they’re comparable. library(edgeR) dge &lt;- DGEList(counts = counts) dge &lt;- calcNormFactors(dge, method = &quot;TMM&quot;) logcpm &lt;- cpm(dge, log = TRUE, prior.count = 1) 4.3.2 DESeq2: size factors RLE finds what “most genes” are doing compared to a typical sample. It adjusts each sample so that the median gene looks the same in all samples. library(DESeq2) dds &lt;- DESeqDataSetFromMatrix(countData = counts, colData = meta, design = ~ condition) dds &lt;- estimateSizeFactors(dds) norm_counts &lt;- counts(dds, normalized = TRUE) 4.4 Single-cell note In scRNA-seq, normalization often starts with per-cell library-size scaling followed by log1p and sometimes variance stabilization. The concepts (make samples comparable; avoid composition artifacts) are the same. "],["worked-normalization-examples.html", "Chapter 5 Worked normalization examples 5.1 Setup: download supplementary files 5.2 load Some data 5.3 Example 1: GSE119732 5.4 Convert the raw counts to Counts per million (CPM) 5.5 filter out lowly expressed genes 5.6 Incorporate a design matrix - description of the samples. 5.7 Normalize Dataset using TMM 5.8 Look at the distribution of our samples in 2D space 5.9 Normalize the Dataset using RLE", " Chapter 5 Worked normalization examples We will demonstrate exploratory normalization steps on the expression datasets. 5.1 Setup: download supplementary files 5.2 load Some data library(GEOquery) ## Loading required package: Biobase ## Loading required package: BiocGenerics ## Loading required package: generics ## ## Attaching package: &#39;generics&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.difftime, as.factor, as.ordered, intersect, is.element, setdiff, ## setequal, union ## ## Attaching package: &#39;BiocGenerics&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, aperm, append, as.data.frame, basename, cbind, ## colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ## get, grep, grepl, is.unsorted, lapply, Map, mapply, match, mget, ## order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, ## rbind, Reduce, rownames, sapply, saveRDS, table, tapply, unique, ## unsplit, which.max, which.min ## Welcome to Bioconductor ## ## Vignettes contain introductory material; view with ## &#39;browseVignettes()&#39;. To cite Bioconductor, see ## &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. ## Setting options(&#39;download.file.method.GEOquery&#39;=&#39;auto&#39;) ## Setting options(&#39;GEOquery.inmemory.gpl&#39;=FALSE) library(knitr) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following object is masked from &#39;package:Biobase&#39;: ## ## combine ## The following objects are masked from &#39;package:BiocGenerics&#39;: ## ## combine, intersect, setdiff, setequal, union ## The following object is masked from &#39;package:generics&#39;: ## ## explain ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(tibble) if(!require(tidyverse)){ install.packages(&quot;tidyvers&quot;,dependencies = FALSE) } ## Loading required package: tidyverse ## Error: package or namespace load failed for &#39;tidyverse&#39;: ## .onAttach failed in attachNamespace() for &#39;tidyverse&#39;, details: ## call: library(pkg, lib.loc = loc, character.only = TRUE, warn.conflicts = FALSE) ## error: there is no package called &#39;lubridate&#39; ## Installing package into &#39;/usr/local/lib/R/site-library&#39; ## (as &#39;lib&#39; is unspecified) ## Warning: package &#39;tidyvers&#39; is not available for this version of R ## ## A version of this package for your version of R might be available elsewhere, ## see the ideas at ## https://cran.r-project.org/doc/manuals/r-patched/R-admin.html#Installing-packages library(tidyverse) gse &lt;- &quot;GSE119732&quot; source(&quot;./supp_functions.R&quot;) fetch_geo_supp(gse = gse) ## Using locally cached version of supplementary file(s) GSE119732 found here: ## data/GSE119732/GSE119732_count_table_RNA_seq.txt.gz path &lt;- file.path(&quot;data&quot;, gse) files &lt;- list.files(path, pattern = &quot;\\\\.txt.gz$|\\\\.tsv.gz$|\\\\.csv.gz$&quot;, full.names = TRUE, recursive = TRUE) Raw table preview library(readr) safe_read &lt;- function(file) { # First attempt: read as TSV df &lt;- tryCatch( readr::read_tsv(file, show_col_types = FALSE), error = function(e) NULL # catch fatal errors ) # If read_tsv failed entirely: if (is.null(df)) { message(&quot;TSV read failed — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If read_tsv returned but with parsing issues: probs &lt;- problems(df) if (nrow(probs) &gt; 0) { message(&quot;Parsing issues detected in TSV — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If everything was fine: return(df) } x &lt;- safe_read(files[1]) kable_head(x[, 1:min(6, ncol(x))], 5, paste(gse,&quot;: raw table preview&quot;)) (#tab:preview_raw)GSE119732 : raw table preview gene_id A1 A2 A3 A4 B1 ENSG00000223972.5 0 0 0 0 0 ENSG00000227232.5 79 119 84 50 80 ENSG00000278267.1 17 10 22 19 19 ENSG00000243485.4 0 0 0 0 0 ENSG00000237613.2 0 0 0 0 0 5.3 Example 1: GSE119732 Before doing anything to this data. What does it look like? plot_box(x[,2:ncol(x)]) plot_density(x[,2:ncol(x)]) 5.4 Convert the raw counts to Counts per million (CPM) library(edgeR) ## Loading required package: limma ## ## Attaching package: &#39;limma&#39; ## The following object is masked from &#39;package:BiocGenerics&#39;: ## ## plotMA x_cpm &lt;- cpm(y = x[,2:ncol(x)]) plot_box(x_cpm,main = &quot;CPM - all genes&quot;) Visualize as a density plot as well plot_density(x_cpm,main = &quot;CPM - all genes, NO design&quot;) There are a lot of genes that have zero expression. That is the majority of them. So we need to get rid of them. 5.5 filter out lowly expressed genes to_remove &lt;- edgeR::filterByExpr(x_cpm,min.count = 3) ## No group or design set. Assuming all samples belong to one group. x_cpm_filtered &lt;- x_cpm[to_remove,] plot_box(x_cpm_filtered,main = &quot;CPM filtered out lowly expressed - \\nNO design matrix&quot;) visualize this as density plot as well. plot_density(x_cpm_filtered,main = &quot;CPM filtered out lowly expressed - \\n - NO design matrix&quot;) 5.6 Incorporate a design matrix - description of the samples. The above was usingn all of the samples the same but this dataset has varying sample types. I might be hard to figure it out just from column names as they are not so informative but let’s just guess colnames(x) ## [1] &quot;gene_id&quot; &quot;A1&quot; &quot;A2&quot; &quot;A3&quot; &quot;A4&quot; &quot;B1&quot; &quot;B2&quot; ## [8] &quot;B3&quot; &quot;B4&quot; &quot;B5&quot; &quot;C1&quot; &quot;C2&quot; &quot;C3&quot; &quot;C4&quot; ## [15] &quot;C5&quot; &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; &quot;D4&quot; &quot;D5&quot; &quot;E1&quot; ## [22] &quot;E2&quot; &quot;E3&quot; &quot;E4&quot; &quot;E5&quot; &quot;F1&quot; &quot;F2&quot; &quot;F3&quot; ## [29] &quot;F4&quot; &quot;F5&quot; #design matrix - samples &lt;- colnames(x)[2:ncol(x)] patient &lt;- substr(samples, 1, 1) celltype &lt;- substr(samples, 2, nchar(samples)) sample_data &lt;- data.frame(samples, patient, celltype) design &lt;- model.matrix(~ 0 + celltype,data = sample_data) rownames(design) &lt;- sample_data$samples colnames(design) &lt;- paste0(&quot;celltype&quot;, levels(factor(celltype))) design ## celltype1 celltype2 celltype3 celltype4 celltype5 ## A1 1 0 0 0 0 ## A2 0 1 0 0 0 ## A3 0 0 1 0 0 ## A4 0 0 0 1 0 ## B1 1 0 0 0 0 ## B2 0 1 0 0 0 ## B3 0 0 1 0 0 ## B4 0 0 0 1 0 ## B5 0 0 0 0 1 ## C1 1 0 0 0 0 ## C2 0 1 0 0 0 ## C3 0 0 1 0 0 ## C4 0 0 0 1 0 ## C5 0 0 0 0 1 ## D1 1 0 0 0 0 ## D2 0 1 0 0 0 ## D3 0 0 1 0 0 ## D4 0 0 0 1 0 ## D5 0 0 0 0 1 ## E1 1 0 0 0 0 ## E2 0 1 0 0 0 ## E3 0 0 1 0 0 ## E4 0 0 0 1 0 ## E5 0 0 0 0 1 ## F1 1 0 0 0 0 ## F2 0 1 0 0 0 ## F3 0 0 1 0 0 ## F4 0 0 0 1 0 ## F5 0 0 0 0 1 ## attr(,&quot;assign&quot;) ## [1] 1 1 1 1 1 ## attr(,&quot;contrasts&quot;) ## attr(,&quot;contrasts&quot;)$celltype ## [1] &quot;contr.treatment&quot; Filter use design information to_remove_withdesign &lt;- edgeR::filterByExpr(x_cpm,min.count = 3, design = design) x_cpm_filtered_withdesign &lt;- x_cpm[to_remove_withdesign,] plot_box(x_cpm_filtered_withdesign,main = &quot;CPM filtered out lowly expressed - \\n - with design matrix&quot;) plot_density(x_cpm_filtered_withdesign,main = &quot;CPM filtered out lowly expressed - \\n - with design matrix&quot;) 5.7 Normalize Dataset using TMM library(edgeR) dge &lt;- DGEList(counts = x[,2:ncol(x)]) dge_filtered &lt;- dge[filterByExpr(dge),] ## Warning in filterByExpr.DGEList(dge): All samples appear to belong to the same ## group. dge_filtered &lt;- calcNormFactors(dge_filtered , method = &quot;TMM&quot;) norm_cpm &lt;- cpm(dge_filtered , log = FALSE, prior.count = 1) plot_box(norm_cpm) plot_density(norm_cpm) 5.8 Look at the distribution of our samples in 2D space y &lt;- dge_filtered plotMDS(y, top = 500, labels = colnames(y), col = as.integer(y$samples$group)) legend(&quot;topright&quot;, legend = levels(y$samples$group), col = seq_along(levels(y$samples$group)), pch = 16, bty = &quot;n&quot;) Now incorporate the design into the process dge &lt;- DGEList(counts = x[,2:ncol(x)],group = sample_data$celltype) dge_filtered &lt;- dge[filterByExpr(dge),] dge_filtered &lt;- calcNormFactors(dge_filtered , method = &quot;TMM&quot;) norm_cpm &lt;- cpm(dge_filtered , log = FALSE, prior.count = 1) plot_box(norm_cpm) plot_density(norm_cpm) y &lt;- dge_filtered plotMDS(y, top = 500, labels = colnames(y), col = as.integer(y$samples$group)) legend(&quot;topright&quot;, legend = levels(y$samples$group), col = seq_along(levels(y$samples$group)), pch = 16, bty = &quot;n&quot;) Now incorporate the design into the process dge &lt;- DGEList(counts = x[,2:ncol(x)],group = sample_data$patient) dge_filtered &lt;- dge[filterByExpr(dge),] dge_filtered &lt;- calcNormFactors(dge_filtered , method = &quot;TMM&quot;) norm_cpm &lt;- cpm(dge_filtered , log = FALSE, prior.count = 1) plot_box(norm_cpm) plot_density(norm_cpm) y &lt;- dge_filtered plotMDS(y, top = 500, labels = colnames(y), col = as.integer(y$samples$group)) legend(&quot;topright&quot;, legend = levels(y$samples$group), col = seq_along(levels(y$samples$group)), pch = 16, bty = &quot;n&quot;) 5.9 Normalize the Dataset using RLE library(DESeq2) ## Loading required package: S4Vectors ## Loading required package: stats4 ## ## Attaching package: &#39;S4Vectors&#39; ## The following object is masked from &#39;package:tidyr&#39;: ## ## expand ## The following objects are masked from &#39;package:dplyr&#39;: ## ## first, rename ## The following object is masked from &#39;package:utils&#39;: ## ## findMatches ## The following objects are masked from &#39;package:base&#39;: ## ## expand.grid, I, unname ## Loading required package: IRanges ## ## Attaching package: &#39;IRanges&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## reduce ## The following objects are masked from &#39;package:dplyr&#39;: ## ## collapse, desc, slice ## Loading required package: GenomicRanges ## Loading required package: GenomeInfoDb ## Loading required package: SummarizedExperiment ## Loading required package: MatrixGenerics ## Loading required package: matrixStats ## ## Attaching package: &#39;matrixStats&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## count ## The following objects are masked from &#39;package:Biobase&#39;: ## ## anyMissing, rowMedians ## ## Attaching package: &#39;MatrixGenerics&#39; ## The following objects are masked from &#39;package:matrixStats&#39;: ## ## colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, ## colCounts, colCummaxs, colCummins, colCumprods, colCumsums, ## colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, ## colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, ## colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, ## colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, ## colWeightedMeans, colWeightedMedians, colWeightedSds, ## colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, ## rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, ## rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, ## rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, ## rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, ## rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, ## rowWeightedMads, rowWeightedMeans, rowWeightedMedians, ## rowWeightedSds, rowWeightedVars ## The following object is masked from &#39;package:Biobase&#39;: ## ## rowMedians counts &lt;- x[,2:ncol(x)] keep &lt;- rowSums(counts &gt;= 10) &gt;= 2 counts_filtered &lt;- counts[keep, ] dds &lt;- DESeqDataSetFromMatrix(countData = counts_filtered, colData = sample_data, design = design) ## converting counts to integer mode dds &lt;- estimateSizeFactors(dds) norm_counts &lt;- counts(dds, normalized = TRUE) plot_box(norm_counts) plot_density(norm_counts) "],["exercises.html", "Chapter 6 Exercises 6.1 Exercise 1 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE119732 6.2 Exercise 2 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE122380 6.3 Exercise 3 -", " Chapter 6 Exercises These are intended to be done after completing the worked examples. 6.1 Exercise 1 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE119732 Using GSE119732, confirm whether the ID column contains Ensembl IDs with version suffixes. Extract the first 20 IDs. Count how many contain a .. Create a new column with versions stripped. Map the identifiers to HGNC symbols. 6.2 Exercise 2 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE122380 Using GSE122380, confirm whether the ID column contains Ensembl IDs with version suffixes. Extract the first 20 IDs. Create a new column with versions stripped. Map the identifiers to HGNC symbols. What is different about this file? 6.3 Exercise 3 - Can you use the worked example to process the above two GEO records? How? "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
